package com.revature.bank;

import java.io.Serializable;
import java.security.MessageDigest;

import com.revature.bank.exceptions.InvalidPasswordException;
import com.revature.bank.validation.Validation;

/**
 * This class represents a password which is ready to be encrypted and sent over
 * a network. The actual password is not stored internally, rather the hash is
 * stored.
 * 
 * @author Jared F bennatt
 *
 */
public class Password implements Serializable {
	/**
	 * generated by eclipse (this is going to have to match on both server and
	 * client side).
	 */
	private static final long serialVersionUID = 8269052501371952723L;

	private final byte[] password;

	/**
	 * Constructor for a password given the internal data.
	 * 
	 * @param password raw bytes that represent the internal data
	 */
	public Password(final byte[] password) {
		this.password = new byte[password.length];

		for (int i = 0; i < password.length; ++i)
			this.password[i] = password[i];
	}

	/**
	 * Returns a new Password object for a password given a String representation of
	 * the password and the MessageDigest (hash function) used to encode it.
	 * 
	 * @param password - String that represents the actual password
	 * @param digest   - MessageDigest object used to hash the password string.
	 * @throws InvalidPasswordException
	 */
	public static Password createPassword(final String password, final MessageDigest digest, final Validation validator)
			throws InvalidPasswordException {
		if (!validator.validatePassword(password))
			throw new InvalidPasswordException(password);
		// use the charset specified by the Banking Interface (which will be UTF-8)
		return new Password(digest.digest(password.getBytes(Bank.DEFAULT_CHARSET)));
	}
}
